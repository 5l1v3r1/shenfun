TITLE: Demo - 1D Poisson equation 
AUTHOR: Mikael Mortensen {copyright|CC BY} Email:mikaem@math.uio.no at Department of Mathematics, University of Oslo.
DATE: today

__Summary.__
This is a demonstration of how the Python module "shenfun":
"https://github.com/spectralDNS/shenfun" can be used to solve the Poisson
equation with Dirichlet boundary conditions in one dimension. The demo is implemented in
a single Python file "dirichlet_poisson1D.py":
"https://github.com/spectralDNS/shenfun/blob/master/demo/dirichlet_poisson1D.py". The numerical method is is described in more details by J. Shen cite{shen1} and cite{shen95}.

TOC: on

======= Model problem =======
===== Poisson equation =====

The Poisson equation is given as

!bt 
\begin{align}
\nabla^2 u(x) &= f(x) \quad \text{for }\, x \in [-1, 1], label{eq:poisson}\\
u(-1)&=a, u(1)=b,
\end{align}
!et
where $u(x)$ is the solution, $f(x)$ is a function and $a, b$ are two possibly
non-zero constants. 

To solve Eq. (ref{eq:poisson}) with the Galerkin method we need smooth basis functions, $v_k$, that live
in the Hilbert space $H^1(x)$ and that satisfy the given boundary conditions. And then we look for solutions
like
!bt
\begin{equation}
u(x) = \sum_{k=0}^{N-1} \hat{u}_k v_k(x), label{eq:u}
\end{equation}
!et

where $N$ is the size of the discretized problem and the basis is $V^N=\text{span}\{v_k\}_{k=0}^{N-1}$.
The basis functions can, for example,  be constructed from "Chebyshev": "https://en.wikipedia.org/wiki/Chebyshev_polynomials", $T_k(x)$, or "Legendre": "https://en.wikipedia.org/wiki/Legendre_polynomials", $L_k(x)$, functions 
and we use the common notation $\phi_k(x)$ to represent either one of them. It turns out that 
it is easiest to use basis functions with homogeneous Dirichlet boundary conditions
!bt
v_k(x) = \phi_k(x) - \phi_{k+2}(x),
!et
for $k=0, 1, \ldots N-3$, and then the last two are added as two linear basis functions (that belong to the kernel of the Poisson equation)
!bt
\begin{align}
v_{N-2} &= \frac{1}{2}(\phi_0 + \phi_1), \\
v_{N-1} &= \frac{1}{2}(\phi_0 - \phi_1).
\end{align}
!et

We now formulate a variational problem using the Galerkin method: Find $u \in V^N$ such that
!bt
\begin{equation}
\int_{-1}^1 \nabla^2 u \, v \, w\, dx = \int_{-1}^1 f \, v\, w\, dx \quad \forall v \, \in \, V^N. label{eq:varform} 
\end{equation}
!et
The weighted integrals, weighted by $w(x)$, are called inner products, and a common notation is
!bt
\int_{-1}^1 u \, v \, w\, dx = \left( u, v\right)_w. 
!et
The integral can either be computed exactly, or with quadrature. The advantage of the latter is that it is generally faster, and that non-linear terms may be computed just as quickly as linear. For a linear problem, it does not make much of a difference, if any at all. Approximating the integral with quadrature, we obtain
!bt
\begin{align}
\int_{-1}^1 u \, v \, w\, dx &\approx \left( u, v \right)_w^N,  \\
&\approx \sum_{j=0}^{N-1} u(x_j) v(x_j) w(x_j),
\end{align}
!et
where $w(x_j)$ are quadrature weights. The quadrature points $\{x_j\}_{j=0}^N$ are specific to the chosen basis, and even within basis there are two different choices based on which quadrature rule is selected, either Gauss or Gauss-Lobatto.

Inserting for test and trialfunctions, we get the following bilinear form and matrix $A\in\mathbb{R}^{N\times N}$ for the Laplacian (using the summation convention in step 2)

!bt
\begin{align*}
\left( \nabla^2u, v \right)_w^N &= \left( \nabla^2\sum_{k=0}^{N-1}\hat{u}_k v_{k}, v_j \right)_w^N, \\
    &= \left(\nabla^2 v_{k}, v_j \right)_w^N \hat{u}_k, \\
    &= A_{jk} \hat{u}_k.
\end{align*}
!et 

Likewise, the right hand side linear form and vector $\tilde{f}_j = (f, v_j)_w^N$, where a tilde is used because this is not a complete transform of the function $f$, but only an inner product. 

The linear system of equations to solve for the expansion coefficients of $u(x)$ is given as

!bt
\begin{equation}
A_{jk} \hat{u}_k = \tilde{f}_j.
\end{equation}
!et 

Now, when $\hat{u}$ is found by solving this linear system, it may be transformed to real space $u(x)$ using (ref{eq:u}). Note that the matrix $A_{jk}$ has a very special structure that allows for a solution to be found very efficiently in order of $\mathcal{O}(N)$ operations, see cite{shen1} and cite{shen95}. 

===== Method of manufactured solutions =====

In this demo we will use the method of manufactured
solutions to demonstrate spectral accuracy of the `shenfun` Dirichlet bases. To
this end we choose an analytical function that satisfies the given boundary
conditions:
!bt
\begin{equation}
u_e(x) = \sin(k\pi x)(1-x^2) + a(1+x)/2 + b(1-x)/2, label{eq:u_e}
\end{equation}
!et
where $k$ is an integer. Now, feeding $u_e$ through the Laplace operator, we see
that the last two linear terms disappear, whereas the first term results in
in
!bt
\begin{align}
 \nabla^2 u_e(x) &= \frac{d^2 u_e}{dx^2}, \\
                  &= -4k \pi x \cos(k\pi x) - 2\sin(k\pi x) - k^2 \pi^2 (1 - x^2) \sin(k \pi x).
\end{align}
!et

Now, setting $f_e(x) = \nabla^2 u_e(x)$ and solving for $\nabla^2 u(x) = f_e(x)$, we can compare the numerical solution $u(x)$ with the analytical solution $u_e(x)$ and compute error norms.


======= Implementation =======



===== Preamble =====

We will solve the Poisson problem using the "shenfun":
"https://github.com/spectralDNS/shenfun" Python module. The first thing needed
is then to import some of this module's functionality
plus some other helper modules, like "Numpy": "https://numpy.org", "Sympy":
"https://sympy.org" and "Matplotlib": "https://matplotlib.org":

!bc pycod  
from shenfun import inner, div, grad, TestFunction, TrialFunction, Function, \
    project, Dx, Array, chebyshev, legendre
import numpy as np
from sympy import symbols, cos, sin, exp, lambdify
!ec

We use `sympy` for the manufactured solution, `matplotlib` for plotting, and `numpy` for testing.

===== Manufactured solution =====

The exact solution $u_e(x)$ and the right hand side $f_e(x)$ are created using `sympy` as follows 
!bc pycod
a = -1
b = 1
k = 4
x = symbols("x")
ue = sin(k*np.pi*x)*(1-x**2) + a*(1 + x)/2. + b*(1 - x)/2.
fe = ue.diff(x, 2)

# Lambdify for faster evaluation
ul = lambdify(x, ue, 'numpy')
fl = lambdify(x, fe, 'numpy')
!ec

These solutions are now valid for a continuous domain $x$. The next step is thus to discretize, using a discrete mesh $\{x_j\}_{j=0}^{N-1}$ and a finite number of basis functions. 

===== Discretization =====

We create a basis with a given number of basis functions, and extract the computational mesh from the basis itself

!bc pycod
N = 32
SD = chebyshev.bases.ShenDirichletBasis(N, plan=True, bc=(a, b))
#SD = legendre.bases.ShenDirichletBasis(N, plan=True, bc=(a, b))
X = SD.mesh(N)
!ec

Note that we can either choose a Legendre or a Chebyshev basis.

===== Variational formulation =====

The variational problem (ref{eq:varform}) can be assembled using `shenfun`'s `TrialFunction`, `TestFunction` and `inner` functions.
!bc pycod
u = TrialFunction(SD)
v = TestFunction(SD)
# Assemble left hand side matrix
A = inner(v, div(grad(u)))
# Assemble right hand side
fj = fl(X)
f_hat = Array(SD)
f_hat = inner(v, fj, output_array=f_hat)
!ec

===== Solve linear equations =====

Finally, solve linear equation system and transform solution from spectral $\{\hat{u}_k\}_{k=0}^{N-1}$ vector to the real space $\{u(x_j)\}_{j=0}^N$ and then check how the solution corresponds with the exact solution $u_e$.
!bc pycod
u_hat = A.solve(f_hat)
uj = SD.backward(u_hat)
ue = ul(X)
print("Error norm = ", np.linalg.norm(uj-ue))
assert np.allclose(uj. ue)
!ec

===== Complete solver =====

A complete solver, that can use either Legendre or Chebyshev bases, chosen as a command-line argument, is shown below. Runs with Legendre 

!bc
>>> python dirichlet_poisson1D.py legendre
!ec
or similarly with `chebyshev` instead of `legendre`.

!bc pycod
import sys
from sympy import symbols, cos, sin, exp, lambdify
import numpy as np
from shenfun import inner, div, grad, TestFunction, TrialFunction, Function, \
    project, Dx, Array

# Collect basis and solver from either Chebyshev or Legendre submodules
basis = sys.argv[-1] if len(sys.argv) == 2 else 'chebyshev'
shen = importlib.import_module('.'.join(('shenfun', basis)))
Basis = shen.bases.ShenDirichletBasis

# Use sympy to compute a rhs, given an analytical solution
a=-1
b=1
x = symbols("x")
ue = sin(4*np.pi*x)*(1-x**2) + a*(1 + x)/2. + b*(1 - x)/2.
fe = ue.diff(x, 2)

# Lambdify for faster evaluation
ul = lambdify(x, ue, 'numpy')
fl = lambdify(x, fe, 'numpy')

# Size of discretization
N = 32

SD = Basis(N, plan=True, bc=(a, b))
X = SD.mesh(N)
u = TrialFunction(SD)
v = TestFunction(SD)

# Get f on quad points
#fj = fl(X)
fj = np.array([fe.subs(x, j) for j in X], dtype=np.float)

# Compute right hand side of Poisson equation
f_hat = Array(SD)
f_hat = inner(v, fj, output_array=f_hat)
if basis == 'legendre':
    f_hat *= -1.

# Get left hand side of Poisson equation
if basis == 'chebyshev':
    A = inner(v, div(grad(u)))
else:
    A = inner(grad(v), grad(u))

f_hat = A.solve(f_hat)
uj = SD.backward(f_hat)

# Compare with analytical solution
ua = ul(X)
print(abs(uj-ua).max())
assert np.allclose(uj, ua)

!ec

======= Bibliography =======

## Publish (https://bitbucket.org/logg/publish is used to
## handle references. The line below specifies the name of
## the Publish database file (see the doconce manual for details).

BIBFILE: papers.pub
